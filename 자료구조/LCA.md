
# LCA : 최소 공통 조상

  

## 목차

- 개요

- LCA 정의

- LCA 구조

- LCA 구현

  

## 개요

- (이진) 트리 구조에서 특정 자식들이 공통의 부모를 갖고 있는지 확인하려면?
![image](https://github.com/lynne921/Ssabalja/assets/119817396/2999e006-84ac-431c-88d2-c2dbbacdacae)

  

## LCA 정의

- Least Common Ancester : 최소 공통조상

- 두 정점(u, v)의 가장 가까운 공통조상을 찾는 알고리즘

- 트리를 효율적으로 탐색할 수 있는 알고리즘 고민하기

  

## LCA 구조

  

### 세그먼트 트리
![트리 예시 for segment tree](https://github.com/lynne921/Ssabalja/assets/119817396/180ee9fe-c7d0-4a9e-9aa0-f17eaec10b19)

#### 아이디어

- 위 트리를 전위탐색(DFS)의 순서배열로 나타내보면,

> 1, 2, 3, 2, 4, 5, 4, 2, 1, 6, 1, 7, 8, 7, 1

  

<pre>    </pre>와 같다.

  

- 2와 7이 [(처음) / (마지막)]으로 등장하는 구간을 나타내보면,

> 1, [(2), 3, 2, 4, 5, 4, (2)], 1, 6, 1, [(7), 8, (7)], 1

  

<pre>    </pre>와 같다. 이는 해당 숫자를 root로 하는 서브트리가 된다.

  

- 특정 두 숫자(ex : [u, v] = [5, 8])가 처음 나오는 시점을 시작과 끝으로 하는 서브트리는

> 1, 2, 3, 2, 4, [(5), 4, 2, 1, 6, 1, 7, (8)], 7, 1

  

<pre>    </pre>와 같다. 이 서브트리의 root는 두 숫자의 LCA가 된다.<br>

<pre>    </pre>∴ u를 포함하는 서브트리에서 v를 포함하는 서브트리로 넘어가려면 LCA를 반드시 건너가야 하므로

  

- 두 정점의 거리(촌수)를 구하려면, 노드의 깊이(D : depth)를 저장해서 다음과 같이 구할 수 있다.

> (D[u] - D[LCA]) + (D[v] - D[LCA]) = D[u] + D[v] - 2 * D[LCA]

  

#### 구현

- 트리를 해당 범위 내 가장 작은값을 찾는 세그먼트 트리로 변형한다

1. 트리 전순위 탐색 → 탐색 순으로 리프노드에 [탐색순서, 노드번호, 트리 높이] 갱신

2. 해당 탐색순서를 통해 세그먼트 트리 구현(먼저 탐색한 노드가 먼저 나오도록 하는 트리)

3. 세그먼트 트리를 통해 발견된 순서에 따른 쿼리 가능

  ![세그먼트 트리](https://github.com/lynne921/Ssabalja/assets/119817396/180ee9fe-c7d0-4a9e-9aa0-f17eaec10b19)

### DP

![트리 예시 for segment tree](https://github.com/lynne921/Ssabalja/assets/119817396/180ee9fe-c7d0-4a9e-9aa0-f17eaec10b19)

#### 아이디어

1. 각 자식의 부모를 올라가면서 확인 <br>

- case1) u : 5, v : 8 <br>

> [5] : 4 - 2 - 1 <br>

> [8] : 7 - 1 <br>

- case2) u : 3, v : 5 <br>

> [3] : 2 - 1 <br>

> [5] : 4 - 2 - 1 <br>

- LCA를 만난 이후, 부모의 값이 같아진다!

2. 부모의 배열을 만들어서 상호 비교, 가장 먼저 부모가 같아지는 지점 확인 <br>

#### 구현

- 2차원 배열(DP[i][N])을 정의하고 2<sup>i</sup>번째 부모들을 비트마스킹한다.

- 2^i번째 부모들을 확인하는 이유 : 탐색 시간복잡도를 O(logN)으로 만들기 위해

1. 트리를 탐색하면서 각 노드의 높이를 기록한다.

2. 상향식으로 DP를 갱신한다.

> DP[ i + 1 ][ N ] = DP[ i ][ DP[ i ][ N ] ]

3. DP를 통해 LCA를 구한다.

```

```

## LCA 구현(JAVA)

  

```java

  

```

  

---
