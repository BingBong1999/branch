## 11장. 시스템 -> 시스템을 잘 분리하는 것이 중요하다.

**1. 도시를 세운다면?**
- 세세한 사항은 각 분야를 관리하는 팀에 맡겨야 한다.
- 이러한 추상화와 모듈화 덕분에 도시가 잘 돌아간다.
- 소프트웨어 또한 관심사를 분리하고 추상화를 이뤄내는 것이 중요하다.

**2. 시스템 제작과 시스템 사용을 분리하라.**
- 생성과 관련된 코드는 main or main을 호출하는 모듈로 옮기자.
  - 애플리케이션은 main이나 객체가 생성되는 과정을 모르도록 하자.
      
- 객체가 생성되는 시점을 애플리케이션이 결정해야 할 때는 -> 추상팩토리 패턴을 사용하자.
    
- 의존성 주입은 사용과 제작을 분리하는 강력한 메커니즘이다.
  - 스프링 프레임워크를 사용하게 되면 프로그램이 실행되기 전 의존성 주입이 이뤄진다.
  - 다만, 그렇다면 객체 초기화를 미루었을 때의 얻는 장점은 포기해야 하는가? -> 팩토리를 호출하거나 프록시를 생성하면 된다.

**3. 확장**
- 처음부터 올바르게 시스템을 구축하려고 하지 말자
  
- 오늘 주어진 템포에 맞추어 시스템을 구현하자
  
- 테스트 주도 개발, 리팩터링, 깨끗한 코드는 시스템을 확장하기 쉽게 만든다.
  
- 비즈니스 코드가 컨테이너와 결합되면 -> 독자적인 단위 테스트가 어렵다.
  
- 영속적인 동작(트랜잭션,보안 등)은 소스 코드가 아닌 배치 기술자에서 정의하는 것이 좋다.
  - 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상할 수 있다. -> AOP 프레임워크
 
**4. 자바프록시**
- 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다.
- 프록시는 실행 지점을 명시하는 메커니즘도 제공하지 않는다.

- 그러나 프록시 코드는 도구로 자동화가 가능하다.
  - 개발자는 영속성, 트랜잭션, 보안 같은 횡단관심사들을 설정파일이나 API를 사용하여 구현하는데,
  - 이 때 (스프링과 같은) 프레임워크는 개발자가 모르게 프록시 등을 사용하여 이를 구현한다.
 
**5. AspectJ관점**
- 관심사를 분리하는 강력한 언어이다.

**6. 테스트 주도 시스템 아키텍처 구축**
- 코드 수준에서 아키텍처 관심사를 분리하게 된다면, 그제서야 비로소 진정한 테스트 주도 아키텍처 구축이 가능해진다.
- 프로젝트 결과물을 출시한 후 기반 구조를 추가하여 확장해도 좋지만,
- 그렇다고 아무 방향없이 프로젝트에 뛰어들지는 말자. 프로젝트 범위, 목표, 일정, 구조 등은 생각해야 한다.

**7. 의사 결정을 최적화하라**
- 모듈을 나누고 관심사를 분리하면 지엽적인 분야의 관리가 용이하다.
- 최대한 정보를 모아 최선을 결정을 내리자. 성급하게 결정하지 말자.

**8. 명백한 가치가 있을 때 표준을 현명하게 사용하라**
- 너무 표준에 집착하지 말자.. 유연하게 사고하자..

**시스템은 도메인 특화 언어가 필요하다**
- 도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면, 도메인을 잘못 구현할 가능성이 줄어드니, 사용을 권고한다.(아마?)

---

```java
// 보안 관련 로그인 체크를 담당하는 Aspect 클래스
public aspect SecurityAspect {

    // 로그인 전에 실행되는 Advice
    before(): execution(* com.example.service.*.*(..)) {
        if (!SecurityManager.isLoggedIn()) {
            throw new SecurityException("로그인이 필요합니다.");
        }
    }
}
```
- before advice는 com.example.service 패키지의 모든 메서드가 실행되기 전에 로그인이 되어 있는지 확인하는 역할을 한다.
  
- 해당 코드로 인해 각 서비스 메서드에서 보안 체크를 반복해서 작성할 필요 없이 관심사를 분리하여 코드를 관리할 수 있다.

---

## 12장. 창발성

창발성(Emegence)은 


간단한 개별 요소들 간의 상호작용으로부터 복잡하고 정교한 구조나 행동이 나타나는 현상을 말합니다.


이는 시스템이나 조직, 생물체, 사회 등 다양한 영역에서 관찰될 수 있습니다.

**규칙 1. 모든 테스트를 실행하라**
- 시스템이 의도한 대로 돌아가는지 검증할 수 없다면.. 그 가치는 인정받기 힘들다.
- 테스트가 가능한 시스템을 만들고자 한다면, 설계 품질이 높아진다.
- 그러나 결합도가 높으면 테스트 케이스를 작성하기 어려우므로 결합도를 낮추자 by DI, 인터페이스, 추상화

**규칙 2. 리팩터링**
- 기존의 테스트코드를 믿고 리팩터링을 과감하게 도전하자.
- 응집도를 높이고, 결합도를 낮추고, 관심사를 분리하고, 시스템 관심사를 모듈로 나누고, 함수 및 클래스의 크기를 줄이고, 좋은 이름을 짓도록 노력하자.

**규칙 3. 중복을 없애라**
- 만일, 중복을 없애려고 노력하다 보면 단일책임원칙을 위반하게 되는데, 그럴 때는 해당 메서드를 다른 클래스로 옮기는 방법이 있다.
- 그렇게 되면, 해당 메서드의 재사용할 기회가 생기고, 이러한 재사용은 시스템 복잡도를 극적으로 줄여준다.

**규칙 4. 표현하라**
- 소프트웨어 프로젝트 비용 중 대다수는 거의 장기적인 유지보수에 쓰인다..
- 유지보수 개발자가 이해하기 쉽고 우리가 짠 코드를 오해하지 않도록 개발자의 의도를 분명하게 표현하는 코드를 작성하자.
- 좋은 이름을 선택하자, 함수와 클래스의 크기를 줄이자. 표준 명칭을 사용하자. 단위테스트 케이스를 꼼꼼하게 작성하자. 노력하자...
- 우리가 짠 코드는 미래의 우리가 읽게 될 가능성이 매우 높다.

**클래스와 메서드 수를 최소로 줄여라**
- 그러나 클래스와 메서드 수를 극한으로 줄이지 말고.. 그냥 가능한 줄이자. 적당히... (극한으로 줄이면 득보다 실이 더 많다.)
- 이 원칙은 우선순위가 제일 낮으니 앞에 서술한 규칙들을 더 중요시하여 지키도록 하자.

---
*고차원 중복을 제거할 목적으로 자주 사용되는 TEMPLATE METHOD 패턴의 예시입니다*

```java
// 음료 제조를 위한 추상 클래스
abstract class BeverageMaker {
    // 템플릿 메서드: 음료 제조 과정을 나타내는 알고리즘의 골격
    public final void makeBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    // 보일워터 메서드
    public void boilWater() {
        System.out.println("물을 끓입니다.");
    }

    // 추상 메서드: 각 음료의 특정한 제조 과정
    abstract void brew();

    // 컵에 따르는 메서드
    public void pourInCup() {
        System.out.println("컵에 따르는 중입니다.");
    }

    // 조건부 메서드: 커스터머의 선택에 따라 행동을 결정하는 부분
    boolean customerWantsCondiments() {
        return true;
    }

    // 추상 메서드: 각 음료의 특정한 첨가물 추가 과정
    abstract void addCondiments();
}

// 커피 클래스
class CoffeeMaker extends BeverageMaker {
    // 커피를 끓이는 메서드
    void brew() {
        System.out.println("필터로 커피를 우려내는 중입니다.");
    }

    // 설탕과 우유를 추가하는 메서드
    void addCondiments() {
        System.out.println("설탕과 우유를 추가하는 중입니다.");
    }
}

// 차 클래스
class TeaMaker extends BeverageMaker {
    // 차를 우려내는 메서드
    void brew() {
        System.out.println("차를 우려내는 중입니다.");
    }

    // 레몬을 추가하는 메서드
    void addCondiments() {
        System.out.println("레몬을 추가하는 중입니다.");
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {
        BeverageMaker coffee = new CoffeeMaker();
        coffee.makeBeverage();
        System.out.println("----------------------");
        BeverageMaker tea = new TeaMaker();
        tea.makeBeverage();
    }
}
```
- 해당 디자인 페턴은 알고리즘의 구조를 정의하고 하위 클래스에서 알고리즘의 일부분을 구현할 수 있도록 하는 패턴이다.
- 이 패턴은 상위 클래스에서 알고리즘의 골격을 정의하고, 하위 클래스에서 이를 구체화하는 방식으로 동작한다.



- 해당 예제에서는 여러 종류의 음료를 제조하는 클래스를 작성한다고 가정한다.
- 이 클래스는 음료를 만드는 일련의 단계를 정의하되, 각 단계마다 하위 클래스에서 구체적인 구현을 제공할 수 있도록 하고자 한다.


- 이 예시에서 BeverageMaker 클래스는 템플릿 메서드인 makeBeverage()를 가지고 있다.
- 이 메서드는 음료 제조 과정의 일반적인 순서를 정의하고 있다.


- CoffeeMaker와 TeaMaker 클래스는 BeverageMaker를 상속받아 각각의 음료에 맞는 제조 과정을 구현하고 있다.
- 이러한 구현은 각각의 클래스에서 brew()와 addCondiments() 메서드를 오버라이딩하여 제조 과정을 정의하고 있습니다.


- 이렇게 템플릿 메서드 패턴을 사용하면 코드의 재사용성을 높이고 유지보수를 용이하게 할 수 있습니다.

---
