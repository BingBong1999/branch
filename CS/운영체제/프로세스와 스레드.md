# 프로세스 개요

## 프로세스

보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하면 프로세스가 된다.

## 프로세스 직접 확인하기

윈도우에서는 작업 관리자의 프로세스 탭에서 확인할 수 있다.


**포그라운드 프로세스 foreground process**

→ 사용자가 보는 앞에서 실행되는 프로세스

**백그라운드 프로세스 background process**

→ 사용자가 보지 못하는 뒤에서 실행되는 프로세스, 이 중에서 사용자와 직접 상호작용하지 않는 백그라운드 프로세스를 서비스(윈도우), 데몬(유닉스)이라 부른다.

## 프로세스 제어 블록

프로세스들은 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고 시간이 끝났음을 알리는 인터럽트(타이머 인터럽트)가 발생하면 자신의 차례를 양보하고 다음 차례를 기다린다. → 운영체제는 프로세스 제어 블록을 통해 관리

**프로세스 제어 블록(PCB: Process Control Block)**

- 프로세스와 관련된 정보를 저장하는 자료구조. **커널 영역**에 생성된다.
- **프로세스 생성 시**에 만들어지고 실행이 끝나면 폐기된다.
- 프로세스 제어 블록에 담기는 정보
    - 프로세스 ID(PID): 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    - 레지스터 값: 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다. 이를 위해 PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값이 담긴다.
    - 프로세스 상태: 프로세스 상태 정보가 PCB에 저장된다.
    - CPU 스케줄링 정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보가 기록된다.
    - 메모리 관리 정보: 프로세스마다 메모리에 저장된 위치가 다르기 때문에 프로세스의 메모리 주소를 알 수 있는 베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보가 담긴다.
    - 사용한 파일과 입출력장치 목록: 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용이 명시된다.

## 문맥 교환

문맥(context): 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보, PCB에 기록되는 정보들을 문맥이라고 봐도 무방하다.

**문맥 교환**

기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위한 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것

문맥 교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 수행되기 때문에 프로세스들이 동시에 실행되는 것처럼 보인다.

문맥 교환을 너무 자주하면 오버헤드가 발생할 수 있다.

## 프로세스의 메모리 영역

하나의 프로세스는 사용자 영역에 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장된다.

<img width="45%" src="https://github.com/lynne921/Ssabalja/assets/96831825/c73e3041-196d-4ac9-b1f3-c523cad5f04f"/>


**코드 영역(code segment)**

- 텍스트 영역이라고도 부르며 기계어로 이루어진 명령어가 저장된다.
- 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 읽기 전용(read-only)공간이다.

**데이터 영역(data segment)**

- 프로그램이 실행되는 동안 동안 유지할 데이터가 저장되는 공간이다. 전역 변수(global variable)가 대표적.

—> 코드 영역과 데이터 영역은 크기가 고정되어 있어 **정적 할당 영역**이라고도 부른다.

**힙 영역(heap segment)**

- 프로그래머가 직접 할당할 수 있는 저장 공간
- 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 한다.
- 메모리 공간을 반환하지 않는다면 할당한 공간은 메모리 내에 계속남아 메모리 낭비를 초래한다. 이를 메모리 누수(memory leak)라고 한다.

**스택 영역(stack segment)**

- 데이터를 일시적으로 저장하는 공간, 함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수가 대표적이다.
- 일시적으로 저장할 데이터는 PUSH되고 더 이상 필요하지 않은 데이터는 POP됨으로써 사라진다.

—>힙 영역과 스택 영역은 실시간으로 그 크기가 변할 수 있기 때문에 **동적 할당 영역**이라고 부른다.

<img width="70%" src="https://github.com/lynne921/Ssabalja/assets/96831825/772569a2-123f-425a-8a90-b8bc61d2baf3"/>

# 프로세스 상태와 계층 구조

## 프로세스 상태

**생성 상태(new)**

프로세스를 생성 중인 상태

**준비 상태(ready)**

당장 실행할 수 있지만 아직 자신의 차례가 아니기에 기다리고 있는 상태

**실행 상태(running)**

CPU를 할당받아 실행 중인 상태, 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있다.

**대기 상태(blocked)**

입출력장치의 작업을 기다리는 상태

**종료 상태(terminated)**

프로세스가 종료된 상태. 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

<img width="70%" src="https://github.com/lynne921/Ssabalja/assets/96831825/66fb135a-416d-4495-8c90-f7ceb02c6355"/>

- 디스패치: 준비 상태인 프로세스가 실행 상태로 전환되는 것
- 타이머 인터럽트: 프로세스가 할당된 시간을 모두 사용

## 프로세스 계층 구조

**부모 프로세스**

새 프로세스를 생성한 프로세스

**자식 프로세스**

부모 프로세스에 의해 생성된 프로세스, 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID가 기록되기도 한다.

<img width="70%" src="https://github.com/lynne921/Ssabalja/assets/96831825/88ed48ce-55d4-4c27-9a55-007324174ea6"/>

## 프로세스 생성 기법

**fork**

자기 자신 프로세스의 복사본을 자식 프로세스로 생성하는 시스템 호출

**exec**

자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출

exec를 호출하지 않는 경우 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스가 된다.

# 스레드

## 프로세스와 스레드

**단일 스레드 프로세스** 

실행의 흐름 단위가 하나

**멀티스레드 프로세스** 

하나의 프로세스가 한 번에 여러 일을 동시에 처리한다.

<img width="70%" src="https://github.com/lynne921/Ssabalja/assets/96831825/5d10fdd1-e64a-460d-8b14-631a05a482fa"/>

- 스레드들은 실행에 필요한 최소한의 정보(프로그램 카운터를 포함한 레지스터, 스택)만을 유지한 채 프로세스 자원을 공유하며 실행된다.

프로세스가 실행되는 프로그램이라면 스레드는 프로세스를 구성하는 실행의 흐름 단위이다!

## 멀티프로세스와 멀티스레드

**멀티프로세스(multiprocess)**

여러 프로세스를 동시에 실행하는 것

**멀티스레드(multithread)**

여러 스레드로 프로세스를 동시에 실행하는 것

스레드는 프로세스 내의 자원을 공유하기 때문에 여러 프로세스를 병행 실행하는 것보다 메모리를 효율적으로 사용할 수 있다. 또한 협력과 통신에 유리하다.

<img width="70%" src="https://github.com/lynne921/Ssabalja/assets/96831825/72ffc41a-1c9e-451d-bed3-bd2ebc33fac8"/>

++프로세스끼리도 자원을 공유하고 데이터를 주고받을 수 있음! 이를 프로세스 간 통신(IPC; Inter-Process-Communication)이라고 부른다.
